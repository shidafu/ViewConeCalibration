
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>GetHorizontalEllipse</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-03"><meta name="DC.source" content="GetHorizontalEllipse.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Get the horizontal ellipse from an ellipse in arbitrary direction</a></li><li><a href="#3">Get the angle from cos and sin</a></li></ul></div><h2>Get the horizontal ellipse from an ellipse in arbitrary direction<a name="1"></a></h2><div><ul><li>Author: WANG Lei,USTB</li></ul></div><div><ul><li>Link: <a href="https://github.com/shidafu/ViewConeCalibration.git">https://github.com/shidafu/ViewConeCalibration.git</a></li></ul></div><div><ul><li>Date:2016/3/3</li></ul></div><div><ul><li>Algorithom:</li></ul></div><p>Get [ <i>HEllipse</i> ] [ <i>Rotate</i> ] and  [ <i>Shift</i> ] From [ <i>Ellipse</i> ]:</p><p><img src="GetHorizontalEllipse_eq16381086937273357394.png" alt="$$\left[\begin{array}{ccc} \mathit{x}&amp; \mathit{y}&amp; 1 \end{array}\right]\cdot&#xA;\left[\mathit{Ellipse}\right]\cdot&#xA;\left[\begin{array}{c} \mathit{x}\\ \mathit{y}\\ 1 \end{array}\right]=$$"></p><p><img src="GetHorizontalEllipse_eq07759434252204319530.png" alt="$$\left[\begin{array}{ccc} \mathit{x}&amp; \mathit{y}&amp; 1 \end{array}\right]\cdot&#xA;\left[\mathit{Rotate}\right]^\mathrm{T}\cdot \left[\mathit{Shift}\right]^\mathrm{T}\cdot&#xA;\left[\mathit{HEllipse}\right]\cdot&#xA;\left[\mathit{Shift}\right]\cdot \left[\mathit{Rotate}\right]\cdot&#xA;\left[\begin{array}{c} \mathit{x}\\ \mathit{y}\\ 1 \end{array}\right]=0$$"></p><p>Where:</p><p><img src="GetHorizontalEllipse_eq18092959134573300996.png" alt="$$\left[\mathit{Ellipse}\right]=&#xA;\left[\begin{array}{ccc}&#xA;\mathit{k/a}^{2} &amp; 0 &amp; 0\\&#xA;0 &amp; \mathit{k/b}^{2} &amp; 0\\&#xA;0 &amp; 0 &amp; -\mathit{k}&#xA;\end{array}\right]$$"></p><p><img src="GetHorizontalEllipse_eq03878103207188549436.png" alt="$$\left[\mathit{Rotate}\right]=&#xA;\left[\begin{array}{ccc}&#xA;\mathrm{cos}\mathit{\phi} &amp; \mathrm{sin}\mathit{\phi} &amp; 0\\&#xA;\mathrm{-sin}\mathit{\phi} &amp; \mathrm{cos}\mathit{\phi} &amp; 0\\&#xA;0 &amp; 0 &amp; 1&#xA;\end{array}\right]$$"></p><p><img src="GetHorizontalEllipse_eq12588602675022744499.png" alt="$$\left[\mathit{Shift}\right]=&#xA;\left[\begin{array}{ccc}&#xA;1 &amp; 0 &amp; -\mathit{x}_\mathrm{s}\\&#xA;0 &amp; 1 &amp; -\mathit{y}_\mathrm{s}\\&#xA;0 &amp; 0 &amp; 1&#xA;\end{array}\right]$$"></p><div><ul><li>Inputs:</li></ul></div><pre>   Ellipse----3 by 3 real symmetric matrix;</pre><div><ul><li>Outputs:</li></ul></div><pre>   HEllipse----3 by 3 diagonal matrix;
                [k/(a^2),0,0;
                 0,k/(b^2),0;
                 0,0,k];
   Rotate----3 by 3 rotation matrix;
                [cos(phi),sin(phi),0;
                 -sin(phi),cos(phi),0;
                 0,0,1];
   Shift----3 by 3 shift matrix;
                [0,0,-xs;
                 0,0,-xs;
                 0,0,1];
   a,b,c,e,phi----double value of ellipse para;
   Center----2 by 1 array,Center point of the source ellipse;
   Focus----2 by 1 array,Focus point of the source ellipse;
   Peaks1----2 by 1 array,Peak points in long axis of the source ellipse;
   Peaks2----2 by 1 array,Peak points in short axis of the source ellipse;</pre><pre class="codeinput"><span class="keyword">function</span> [HEllipse,Rotate,Shift,a,b,c,e,phi,Center,Focus,Peaks1,Peaks2] = GetHorizontalEllipse(Ellipse)
</pre><pre class="codeinput"><span class="comment">% Initial</span>
[hE, wE]=size(Ellipse);
<span class="keyword">if</span> ~(hE==3 &amp;&amp; wE==3)
    error(<span class="string">'Input matrix size error!'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ~det(Ellipse)&gt;0 || Ellipse~=Ellipse
    error(<span class="string">'Input matrix is not real symmetric matrix!'</span>);
<span class="keyword">end</span>
<span class="comment">% Algorithm</span>
<span class="comment">% Find a rotate matrix [Rotate]:</span>
<span class="comment">%                 [cos(phi) sin(phi) 0</span>
<span class="comment">%      [Rotate] = -sin(phi) cos(phi) 0</span>
<span class="comment">%                     0        0     1]</span>
<span class="comment">% Fit the equation:</span>
<span class="comment">%       [x]'*[Ellipse]*[x]=[x]'*[Rotate]'*[D]*[Rotate]*[x]=0</span>
<span class="comment">% Thus: [Ellipse]=[Rotate]'*[D]*[Rotate]</span>
<span class="comment">%       [D]=[Rotate]*[Ellipse]*[Rotate]'</span>
<span class="comment">% Find a rotate matrix [Rotate] to make[D]:</span>
<span class="comment">%       [D](1,2) and [D](2,1)=0</span>
<span class="comment">% By solving orthogonal eigenvectors of[Ellipse](1:2,1:2):</span>
<span class="comment">%       [Ellipse(1:2,1:2)]*[Rotate]' = [Rotate]'*[D]</span>
[V,D] = eig(Ellipse(1:2,1:2));
Rotate=orth(V)';
<span class="keyword">if</span> Rotate(1,2)*Rotate(2,1)&gt;0 || Rotate(1,1)*Rotate(2,2)&lt;0
    Rotate=Rotate(:,2:-1:1);
    D=[D(2,2) 0;0 D(1,1)];
<span class="keyword">end</span>
Rotate=[Rotate [0;0];0 0 1];
<span class="comment">% Fix rotation 90</span>
R90=[1 0 0;<span class="keyword">...</span>
     0 1 0 ;<span class="keyword">...</span>
     0 0 1];
<span class="keyword">if</span>(a&lt;b)
    R90=[cos(pi/2)  sin(pi/2) 0;<span class="keyword">...</span>
        -sin(pi/2)  cos(pi/2) 0 ;<span class="keyword">...</span>
          0          0       1];
<span class="keyword">else</span>
<span class="keyword">end</span>
Rotate=Rotate*R90;
D=Rotate*Ellipse*Rotate';
<span class="comment">% Find a shift matrix [Shift] and [HEllipse]</span>
<span class="comment">% Since:</span>
<span class="comment">%     clc</span>
<span class="comment">%     syms x0 y0 real;</span>
<span class="comment">%     S=[1 0 -x0;0 1 -y0;0 0 1];</span>
<span class="comment">%     syms d11 d13 d22 d23 d33 real;</span>
<span class="comment">%     D=[d11 0 d13;...</span>
<span class="comment">%        0 d22 d23;...</span>
<span class="comment">%        d13 d23 d33];</span>
<span class="comment">%     syms l1 l2 l3 real;</span>
<span class="comment">%     HEllipse=[l1 0 0;...</span>
<span class="comment">%               0 l2 0;...</span>
<span class="comment">%               0 0 l3];</span>
<span class="comment">%     D=S'*L*S=</span>
<span class="comment">%     [     l1,      0,                 -l1*x0]</span>
<span class="comment">%     [      0,     l2,                 -l2*y0]</span>
<span class="comment">%     [ -l1*x0, -l2*y0, l1*x0^2 + l2*y0^2 + l3]</span>
<span class="comment">% Thus:</span>
<span class="comment">%     HEllipse(1,1)=D(1,1)</span>
<span class="comment">%     HEllipse(2,2)=D(2,2)</span>
<span class="comment">%     HEllipse(3,3)=D(3,3)-D(1,3)*D(1,3)/D(1,1)-D(2,3)*D(2,3)/D(2,2);</span>
HEllipse=D;
HEllipse(3,3)=HEllipse(3,3)-HEllipse(1,3)*HEllipse(1,3)/HEllipse(1,1)-<span class="keyword">...</span>
              HEllipse(2,3)*HEllipse(2,3)/HEllipse(2,2);
HEllipse(1,3)=0;
HEllipse(2,3)=0;
HEllipse(3,1)=0;
HEllipse(3,2)=0;
HEllipse=HEllipse./-HEllipse(3,3);
a=sqrt(1/HEllipse(1,1));
b=sqrt(1/HEllipse(2,2));

xs=-D(1,3)/D(1,1);
ys=-D(2,3)/D(2,2);
x0y0=Rotate'*[xs;ys;1];
Center=x0y0(1:2,1);
Shift=[1 0 -xs;0 1 -ys;0 0 1];

phi=acossin([Rotate(1,1) Rotate(1,2)]);
c=sqrt((a^2-b^2));
e=c/(a);

<span class="comment">% Get Focus</span>
Focus=[c*cos(theta),-c*cos(theta);c*sin(theta),-c*sin(theta)];
Focus(:,1)=Focus(:,1)+Center;
Focus(:,2)=Focus(:,2)+Center;
<span class="comment">% Get Peaks1,Peaks2</span>
Peaks1=[a*cos(theta),-a*cos(theta);a*sin(theta),-a*sin(theta)];
Peaks1(:,1)=Peaks1(:,1)+Center;
Peaks1(:,2)=Peaks1(:,2)+Center;
Peaks2=[b*cos(theta+pi/2),-b*cos(theta+pi/2);b*sin(theta+pi/2),-b*sin(theta+pi/2)];
Peaks2(:,1)=Peaks2(:,1)+Center;
Peaks2(:,2)=Peaks2(:,2)+Center;
</pre><pre class="codeoutput error">Error using GetHorizontalEllipse (line 70)
Not enough input arguments.
</pre><h2>Get the angle from cos and sin<a name="3"></a></h2><div><ul><li>Inputs:</li></ul></div><pre>   R---[cos(theta) sin(theta)]</pre><div><ul><li>Outputs:</li></ul></div><pre>   phi---Between [-pi pi)</pre><pre class="codeinput"><span class="keyword">function</span> [phi] = acossin(R)
<span class="keyword">if</span> R(1,1)&gt;0 <span class="comment">%cos(theta)</span>
    <span class="keyword">if</span> R(1,2)&gt;0 <span class="comment">%sin(theta) 1st quad</span>
        <span class="keyword">if</span>(R(1,1)&gt;R(1,2)) <span class="comment">%&lt;45'</span>
            phi=asin(R(1,2));
        <span class="keyword">else</span><span class="comment">%&gt;45'</span>
            phi=acos(R(1,1));
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">%4th quad</span>
        <span class="keyword">if</span>(R(1,1)&gt;-R(1,2)) <span class="comment">%&gt;-45'</span>
            phi=asin(R(1,2));
        <span class="keyword">else</span><span class="comment">%&lt;-45'</span>
            phi=-acos(R(1,1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="keyword">if</span> R(1,2)&gt;0 <span class="comment">%sin(theta) 2nd quad</span>
        <span class="keyword">if</span>(-R(1,1)&gt;R(1,2)) <span class="comment">%&gt;135'</span>
            phi=pi-asin(R(1,2));
        <span class="keyword">else</span><span class="comment">%&lt;135'</span>
            phi=acos(R(1,1));
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">%3rd quad</span>
        <span class="keyword">if</span>(-R(1,1)&gt;-R(1,2)) <span class="comment">%&lt;-135'</span>
            phi=-pi-asin(R(1,2));
        <span class="keyword">else</span><span class="comment">%&lt;135'</span>
            phi=-acos(R(1,1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Get the horizontal ellipse from an ellipse in arbitrary direction
% * Author: WANG Lei,USTB
%
% * Link: <https://github.com/shidafu/ViewConeCalibration.git>
%
% * Date:2016/3/3
%
% * Algorithom:
%
% Get [ _HEllipse_ ] [ _Rotate_ ] and  [ _Shift_ ] From [ _Ellipse_ ]:
%
% $$\left[\begin{array}{ccc} \mathit{x}& \mathit{y}& 1 \end{array}\right]\cdot
% \left[\mathit{Ellipse}\right]\cdot
% \left[\begin{array}{c} \mathit{x}\\ \mathit{y}\\ 1 \end{array}\right]=$$
%
% $$\left[\begin{array}{ccc} \mathit{x}& \mathit{y}& 1 \end{array}\right]\cdot
% \left[\mathit{Rotate}\right]^\mathrm{T}\cdot \left[\mathit{Shift}\right]^\mathrm{T}\cdot
% \left[\mathit{HEllipse}\right]\cdot
% \left[\mathit{Shift}\right]\cdot \left[\mathit{Rotate}\right]\cdot
% \left[\begin{array}{c} \mathit{x}\\ \mathit{y}\\ 1 \end{array}\right]=0$$
%
% Where:
%
% $$\left[\mathit{Ellipse}\right]=
% \left[\begin{array}{ccc} 
% \mathit{k/a}^{2} & 0 & 0\\
% 0 & \mathit{k/b}^{2} & 0\\
% 0 & 0 & -\mathit{k}  
% \end{array}\right]$$
%
% $$\left[\mathit{Rotate}\right]=
% \left[\begin{array}{ccc} 
% \mathrm{cos}\mathit{\phi} & \mathrm{sin}\mathit{\phi} & 0\\
% \mathrm{-sin}\mathit{\phi} & \mathrm{cos}\mathit{\phi} & 0\\
% 0 & 0 & 1  
% \end{array}\right]$$
%
% $$\left[\mathit{Shift}\right]=
% \left[\begin{array}{ccc} 
% 1 & 0 & -\mathit{x}_\mathrm{s}\\
% 0 & 1 & -\mathit{y}_\mathrm{s}\\
% 0 & 0 & 1  
% \end{array}\right]$$
%
% * Inputs:
%
%     EllipseREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH3 by 3 real symmetric matrix;
%
% * Outputs:
%
%     HEllipseREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH3 by 3 diagonal matrix;
%                  [k/(a^2),0,0;
%                   0,k/(b^2),0;
%                   0,0,k];
%     RotateREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH3 by 3 rotation matrix;
%                  [cos(phi),sin(phi),0;
%                   -sin(phi),cos(phi),0;
%                   0,0,1];
%     ShiftREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH3 by 3 shift matrix;
%                  [0,0,-xs;
%                   0,0,-xs;
%                   0,0,1];
%     a,b,c,e,phiREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHdouble value of ellipse para;
%     CenterREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH2 by 1 array,Center point of the source ellipse;
%     FocusREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH2 by 1 array,Focus point of the source ellipse;
%     Peaks1REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH2 by 1 array,Peak points in long axis of the source ellipse;
%     Peaks2REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH2 by 1 array,Peak points in short axis of the source ellipse;
function [HEllipse,Rotate,Shift,a,b,c,e,phi,Center,Focus,Peaks1,Peaks2] = GetHorizontalEllipse(Ellipse)
% Initial
[hE, wE]=size(Ellipse);
if ~(hE==3 && wE==3)
    error('Input matrix size error!');
end
if ~det(Ellipse)>0 || Ellipse~=Ellipse
    error('Input matrix is not real symmetric matrix!');
end
% Algorithm
% Find a rotate matrix [Rotate]:
%                 [cos(phi) sin(phi) 0
%      [Rotate] = -sin(phi) cos(phi) 0
%                     0        0     1]
% Fit the equation:
%       [x]'*[Ellipse]*[x]=[x]'*[Rotate]'*[D]*[Rotate]*[x]=0
% Thus: [Ellipse]=[Rotate]'*[D]*[Rotate]
%       [D]=[Rotate]*[Ellipse]*[Rotate]'
% Find a rotate matrix [Rotate] to make[D]:
%       [D](1,2) and [D](2,1)=0
% By solving orthogonal eigenvectors of[Ellipse](1:2,1:2):
%       [Ellipse(1:2,1:2)]*[Rotate]' = [Rotate]'*[D]
[V,D] = eig(Ellipse(1:2,1:2));
Rotate=orth(V)';
if Rotate(1,2)*Rotate(2,1)>0 || Rotate(1,1)*Rotate(2,2)<0
    Rotate=Rotate(:,2:-1:1);
    D=[D(2,2) 0;0 D(1,1)];
end
Rotate=[Rotate [0;0];0 0 1];
% Fix rotation 90
R90=[1 0 0;...
     0 1 0 ;...
     0 0 1];
if(a<b)
    R90=[cos(pi/2)  sin(pi/2) 0;...
        -sin(pi/2)  cos(pi/2) 0 ;...
          0          0       1];
else
end
Rotate=Rotate*R90;
D=Rotate*Ellipse*Rotate';
% Find a shift matrix [Shift] and [HEllipse]
% Since:
%     clc
%     syms x0 y0 real;
%     S=[1 0 -x0;0 1 -y0;0 0 1];
%     syms d11 d13 d22 d23 d33 real;
%     D=[d11 0 d13;...
%        0 d22 d23;...
%        d13 d23 d33];
%     syms l1 l2 l3 real;
%     HEllipse=[l1 0 0;...
%               0 l2 0;...
%               0 0 l3];
%     D=S'*L*S=
%     [     l1,      0,                 -l1*x0]
%     [      0,     l2,                 -l2*y0]
%     [ -l1*x0, -l2*y0, l1*x0^2 + l2*y0^2 + l3]
% Thus:
%     HEllipse(1,1)=D(1,1)
%     HEllipse(2,2)=D(2,2)
%     HEllipse(3,3)=D(3,3)-D(1,3)*D(1,3)/D(1,1)-D(2,3)*D(2,3)/D(2,2);
HEllipse=D;
HEllipse(3,3)=HEllipse(3,3)-HEllipse(1,3)*HEllipse(1,3)/HEllipse(1,1)-...
              HEllipse(2,3)*HEllipse(2,3)/HEllipse(2,2);
HEllipse(1,3)=0;
HEllipse(2,3)=0;
HEllipse(3,1)=0;
HEllipse(3,2)=0;
HEllipse=HEllipse./-HEllipse(3,3);
a=sqrt(1/HEllipse(1,1));
b=sqrt(1/HEllipse(2,2));

xs=-D(1,3)/D(1,1);
ys=-D(2,3)/D(2,2);
x0y0=Rotate'*[xs;ys;1];
Center=x0y0(1:2,1);
Shift=[1 0 -xs;0 1 -ys;0 0 1];

phi=acossin([Rotate(1,1) Rotate(1,2)]);
c=sqrt((a^2-b^2));
e=c/(a);

% Get Focus
Focus=[c*cos(theta),-c*cos(theta);c*sin(theta),-c*sin(theta)];
Focus(:,1)=Focus(:,1)+Center;
Focus(:,2)=Focus(:,2)+Center;
% Get Peaks1,Peaks2
Peaks1=[a*cos(theta),-a*cos(theta);a*sin(theta),-a*sin(theta)];
Peaks1(:,1)=Peaks1(:,1)+Center;
Peaks1(:,2)=Peaks1(:,2)+Center;
Peaks2=[b*cos(theta+pi/2),-b*cos(theta+pi/2);b*sin(theta+pi/2),-b*sin(theta+pi/2)];
Peaks2(:,1)=Peaks2(:,1)+Center;
Peaks2(:,2)=Peaks2(:,2)+Center;

%% Get the angle from cos and sin
%
% * Inputs:
%
%     RREPLACE_WITH_DASH_DASH-[cos(theta) sin(theta)]
%
% * Outputs:
%
%     phiREPLACE_WITH_DASH_DASH-Between [-pi pi)
function [phi] = acossin(R)
if R(1,1)>0 %cos(theta)
    if R(1,2)>0 %sin(theta) 1st quad
        if(R(1,1)>R(1,2)) %<45'
            phi=asin(R(1,2));
        else%>45'
            phi=acos(R(1,1));
        end
    else %4th quad
        if(R(1,1)>-R(1,2)) %>-45'
            phi=asin(R(1,2));
        else%<-45'
            phi=-acos(R(1,1));
        end
    end
else
    if R(1,2)>0 %sin(theta) 2nd quad
        if(-R(1,1)>R(1,2)) %>135'
            phi=pi-asin(R(1,2));
        else%<135'
            phi=acos(R(1,1));
        end
    else %3rd quad
        if(-R(1,1)>-R(1,2)) %<-135'
            phi=-pi-asin(R(1,2));
        else%<135'
            phi=-acos(R(1,1));
        end
    end
end
##### SOURCE END #####
--></body></html>